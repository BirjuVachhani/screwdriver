// Author: Birju Vachhani
// Created Date: April 05, 2021

import 'dart:io';

import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/file_system/physical_file_system.dart';
import 'package:analyzer/source/line_info.dart';
import 'package:analyzer/src/dart/analysis/analysis_context_collection.dart';
import 'package:args/args.dart';
import 'package:intl/intl.dart';
import 'package:screwdriver/screwdriver.dart';

class Stats {
  List<FunctionElement> functions = [];
  List<ClassElement> classes = [];
  List<PropertyAccessorElement> variables = [];
  List<ExtensionElement> extensions = [];
  List<TypeDefiningElement> typedefs = [];
  List<MixinElement> mixins = [];

  Stats({
    required this.functions,
    required this.classes,
    required this.variables,
    required this.extensions,
    required this.typedefs,
    required this.mixins,
  });

  Stats operator +(Stats other) => Stats(
        functions: functions + other.functions,
        classes: classes + other.classes,
        variables: variables + other.variables,
        extensions: extensions + other.extensions,
        typedefs: typedefs + other.typedefs,
        mixins: mixins + other.mixins,
      );
}

/// Script to generate stats for this package.
/// Usage: dart scripts/extensions_docs_generator.dart [--dry]
/// --dry: if provided, it will not update EXTENSIONS.md file. It will only print
/// the stats to console.
void main(List<String> args) async {
  final screwdriverStats =
      await getStats('package:screwdriver/screwdriver.dart');
  final screwdriverIoStats =
      await getStats('package:screwdriver/screwdriver_io.dart');

  final parser = ArgParser()
    ..addFlag('dry', abbr: 'd', defaultsTo: false)
    ..addOption('output', abbr: 'o', defaultsTo: '../EXTENSIONS.md')
    ..parse(args);

  final argsResult = parser.parse(args);

  final isDry = argsResult.wasParsed('dry');

  final stats = screwdriverStats + screwdriverIoStats;

  final IOSink sink;
  if (!isDry) {
    print('Updating EXTENSIONS.md...');

    final String path = argsResult.wasParsed('output')
        ? argsResult['output'].toString()
        : '../EXTENSIONS.md';

    final outputFile = File(path);
    if (!outputFile.existsSync()) outputFile.createSync();

    var content = outputFile.readAsStringSync();
    outputFile.writeAsStringSync(content);
    sink = outputFile.openWrite();
  } else {
    print('Dry run, not updating EXTENSIONS.md...');
    sink = stdout;
  }

  outputExtensions(sink, stats, isDry: isDry);
  outputFunctions(sink, stats, isDry: isDry);

  if (!isDry) sink.close();
}

void outputExtensions(IOSink sink, Stats stats, {required bool isDry}) {
  sink.writeln('# Extensions');
  sink.writeln(
      '> *This file is auto generated. Do not edit this file manually.*');
  sink.writeln(
      '> *Last Updated: ${DateFormat('EEE, MMM dd, yyyy - hh:mm a').format(DateTime.now())}*');
  sink.writeln('\n');

  for (final extension in stats.extensions) {
    String path = extension.source.toString();
    final String githubFilePath = path.replaceAll(RegExp(r'.*lib'),
        'https://github.com/BirjuVachhani/screwdriver/blob/main/lib');
    final DartType type = extension.extendedType;
    if (type is TypeParameterType) {
      sink.writeln('### on ${type.bound}');
    } else {
      sink.writeln('### on ${extension.extendedType}');
    }

    // table header
    sink.writeln('| Extension | Type | Description |');
    sink.writeln('|---|---|---|');

    for (final accessor in extension.accessors) {
      final description =
          sanitizeDocComment(accessor.documentationComment ?? 'Not provided');
      final String type = accessor.isGetter
          ? 'getter'
          : accessor.isSetter
              ? 'setter'
              : accessor.isOperator
                  ? 'operator'
                  : 'operator';

      final lineNumber = LineInfo.fromContent(accessor.source.contents.data)
          .getLocation(accessor.nameOffset)
          .lineNumber;

      sink.writeln(
          '| [`${accessor.displayName}`]($githubFilePath#L$lineNumber) | `${type.toUpperCase()}` | $description |');
    }

    for (final MethodElement method in extension.methods) {
      // Get the line number of the method
      final lineNumber = LineInfo.fromContent(method.source.contents.data)
          .getLocation(method.nameOffset)
          .lineNumber;

      final description =
          sanitizeDocComment(method.documentationComment ?? 'Not provided');
      sink.writeln(
          '| [`${method.displayName}`]($githubFilePath#L$lineNumber) | `METHOD` | $description |');
    }

    sink.writeln('\n');
  }
}

void outputFunctions(IOSink sink, Stats stats, {required bool isDry}) {
  sink.writeln('# Functions');

  // table header
  sink.writeln('| Name | Description |');
  sink.writeln('|---|---|');

  for (final function in stats.functions) {
    String path = function.source.toString();
    final String githubFilePath = path.replaceAll(RegExp(r'.*lib'),
        'https://github.com/BirjuVachhani/screwdriver/blob/main/lib');

    // Get the line number of the method
    final lineNumber = LineInfo.fromContent(function.source.contents.data)
        .getLocation(function.nameOffset)
        .lineNumber;

    final description =
        sanitizeDocComment(function.documentationComment ?? 'Not provided');
    sink.writeln(
        '| [`${function.displayName}`]($githubFilePath#L$lineNumber) | $description |');
  }
  sink.writeln('\n');
}

String sanitizeDocComment(String comment) {
  return comment
      .trim()
      .replaceAll('///', '')
      // remove \n from description
      .replaceAll('\n', ' ')
      // remove [] from description
      .splitMapJoin(
    RegExp(r'\[(\S+)\]'),
    onMatch: (match) {
      final block = match.group(1);
      if (block == null) return match[0]!;
      return '`$block`';
    },
  ).capitalized;
}

Future<Stats> getStats(String library) async {
  final collection = AnalysisContextCollectionImpl(
      includedPaths: <String>[Directory('lib').absolute.path],
      resourceProvider: PhysicalResourceProvider.INSTANCE);
  final session = collection.contexts[0].currentSession;
  final libPath = session.uriConverter.uriToPath(Uri.parse(library)) ?? '';
  // ignore: deprecated_member_use
  final result =
      await session.getResolvedLibrary(libPath) as ResolvedLibraryResult;
  var helpersFunctions = <FunctionElement>[];
  var helpersClasses = <ClassElement>[];
  var helperVariables = <PropertyAccessorElement>[];
  var extensions = <ExtensionElement>[];
  var typedefs = <TypeDefiningElement>[];
  var mixins = <MixinElement>[];

  for (final part in result.element.units) {
    helpersFunctions += part.functions.wherePublic().toList();
    extensions += part.extensions.wherePublic().toList();
    helpersClasses += part.classes.wherePublic().toList();
    helperVariables += part.accessors.wherePublic().toList();
    typedefs += part.typeAliases.wherePublic().toList();
    mixins += part.mixins.wherePublic().toList();
  }

  final stats = Stats(
    variables: helperVariables,
    classes: helpersClasses,
    functions: helpersFunctions,
    extensions: extensions,
    typedefs: typedefs,
    mixins: mixins,
  );

  collectExports(result.element, stats, checkForSrcDir: true);
  return stats;
}

void collectExports(LibraryOrAugmentationElement element, Stats stats,
    {bool checkForSrcDir = false}) {
  for (final exp in element.libraryExports) {
    final uri = exp.uri;
    if (uri is! DirectiveUriWithLibrary) continue;
    if (!checkForSrcDir || uri.relativeUriString.startsWith('src') == true) {
      for (final unit in exp.exportedLibrary!.units) {
        stats.classes.addAll(unit.classes.wherePublic());
        stats.functions.addAll(unit.functions.wherePublic());
        stats.variables.addAll(unit.accessors.wherePublic());
        stats.extensions += unit.extensions.wherePublic().toList();
        stats.extensions += unit.extensions.wherePublic().toList();
        stats.typedefs += unit.typeAliases.wherePublic().toList();
        stats.mixins += unit.mixins.wherePublic().toList();

        if (unit.enclosingElement.libraryExports.isNotEmpty) {
          collectExports(unit.enclosingElement, stats);
        }
      }
    }
  }
}

extension ElementListExt<T extends Element> on List<T> {
  Iterable<T> wherePublic() => where((element) => element.isPublic);
}
